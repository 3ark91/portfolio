"""
COSC350 - Assignment 2
Author: Mark Hay (220204473)
Contact: mhay23@myune.edu.au
Date: 10/09/2022

Write a program to find the solution to a specific 9x9 grid Sudoku puzzle.
"""
import copy
import random

start_state = [[9, 0, 0, 1, 7, 0, 4, 0, 2],
               [1, 6, 0, 0, 4, 0, 0, 9, 5],
               [0, 0, 8, 0, 0, 3, 0, 0, 0],
               [0, 1, 0, 9, 0, 0, 5, 7, 3],
               [0, 4, 0, 0, 0, 0, 0, 2, 0],
               [5, 8, 9, 0, 0, 7, 0, 1, 0],
               [0, 0, 0, 4, 0, 0, 7, 0, 0],
               [6, 7, 0, 0, 2, 0, 0, 5, 8],
               [3, 0, 1, 0, 5, 8, 0, 0, 6]]

# the default 'chromosome' for a sudoku grid
missing_values = [1, 1, 1, 1,
                  2, 2, 2, 2, 2, 2,
                  3, 3, 3, 3, 3, 3,
                  4, 4, 4, 4, 4,
                  5, 5, 5, 5,
                  6, 6, 6, 6, 6, 6,
                  7, 7, 7, 7,
                  8, 8, 8, 8, 8,
                  9, 9, 9, 9, 9]

max_simulations = 10
max_generations = 300
current_generation = 1
num_instances = 400
num_parents = 100

instances = []              # global reference to all sudoku instances
all_ids = []                # track all sudoku ids

info = f"""
COSC350 - Assignment 2
Author - Mark Hay - mhay23 (220204473)
Contact - mhay23@myune.edu.au
Date - 10/09/2022

Algorithm - The program uses evolutionary programming to discover the solution. The program initialises {num_instances} 
sudoku instances and fills each with a random permutation of the missing numbers. The permutation is stored and treated 
as the chromosome for each instance.

Each sudoku is assigned a fitness value determined by the number of contradictions in the grid i.e. the same number 
occurring twice in a column, row or 3x3 subgrid is a contradiction. This means that a lower fitness value is more 
desirable and ultimately the solution will be found when there are 0 contradictions in the grid. 

The algorithm selects the {num_parents} best parents from the current generation based on their fitness function.

A child is generated by randomly selecting one of the best parents and performing a simple swap mutation on two random 
genes in its chromosome.

The next generation is populated by the {num_parents} best parents and the {num_instances - num_parents} mutated children.

If the {max_generations}th generation is reached the population is considered stagnant and a new simulation is commenced
using a newly initalised population.

The algorithm will run for {max_simulations} simulations and commonly find the solution within the first 5 simulations.
"""


# Sudoku class start
class Sudoku:

    def __init__(self, id, state=start_state, chrom=missing_values):
        self.id = id
        self.state = state
        self.chrom = chrom
        self.update_state()
        self.fitness = fitness_function(self)

    def get_id(self):
        return self.id

    def get_state(self):
        return self.state

    def set_state(self, new_state):
        self.state = new_state

    def get_chromosome(self):
        return self.chrom

    def set_chromosome(self, new_chrom):
        self.chrom = new_chrom
        self.update_state()                 # update state when chromosome changes

    def get_fitness(self):
        return self.fitness

    def set_fitness(self):
        self.fitness = fitness_function(self)

    def update_state(self):
        chrom = copy.deepcopy(self.get_chromosome())        # destroy a copy of the chromosome

        new_state = copy.deepcopy(start_state)

        # replace zero's from the start state with 'genes' from the chromosome, fill order is always the same
        for i, row in enumerate(new_state):
            for j, value in enumerate(row):
                if value == 0:
                    chosen = chrom.pop(0)
                    new_state[i][j] = chosen

        self.set_state(new_state)
        self.set_fitness()              # only calculate fitness when state changes for efficiency

    def get_submatrix_values(self):
        """return an array containing the collated values of each 3x3 sub matrix"""
        subs = [[] for _ in range(9)]
        for i in range(3):
            for j in range(3):
                subs[0].append(self.state[i][j])
                subs[1].append(self.state[i][j+3])
                subs[2].append(self.state[i][j+6])
                subs[3].append(self.state[i+3][j])
                subs[4].append(self.state[i+3][j+3])
                subs[5].append(self.state[i+3][j+6])
                subs[6].append(self.state[i+6][j])
                subs[7].append(self.state[i+6][j+3])
                subs[8].append(self.state[i+6][j+6])
        return subs

    def print_grid(self):
        """print an ascii representation of the sudoku grid to the console"""
        print('-'*59+'\n'+'-'*59)
        for i, line in enumerate(self.state):
            print('|', end="")
            for j, value in enumerate(line):
                if value == 0:
                    print(f'|     ', end="")
                else:
                    print(f'|  {value}  ', end="")
                if j % 3 == 2:
                    print('|', end="")
            print('|')
            print('-'*59)
            if i % 3 == 2:
                print('-'*59)
# Sudoku class end


# Genetic algorithm start
def initialise(num_instances):
    """initialise the initial population of sudoku instances with random chromosomes"""
    global instances
    global missing_values

    instances = []

    for i in range(num_instances):
        random_chrom = list(missing_values)
        random.shuffle(random_chrom)
        instances.append(Sudoku(i, chrom=random_chrom))
        all_ids.append(i)                   # record all ids


def fitness_function(sudoku):
    """count the number of contradictions that exist within the sudoku state. A contradiction is the same number
    occurring multiple times in the same row, column, or 3x3 sub-matrix. A state with 0 contradictions is the solution"""
    count = 0
    columns = [[] for _ in range(9)]

    # check rows - sets can only contain unique values, a shortened set indicates the number of contradictions
    for i, row in enumerate(sudoku.get_state()):
        count += 9 - len(set(row))
        # collate column values while we're here
        for j in range(9):
            columns[j].append(row[j])

    # check columns
    for column in columns:
        count += 9 - len(set(column))

    # check 3x3 grids
    grids = sudoku.get_submatrix_values()
    for grid in grids:
        count += 9 - len(set(grid))

    return count


def selection(x, sudokus):
    """return the ids of the x best performing sudokus"""
    rankings = []

    # collate sudokus and their corresponding fitness
    for sudoku in sudokus:
        rankings.append((sudoku, sudoku.get_fitness()))

    # sort based on fitness
    rankings.sort(key=lambda y: y[1])

    # extract ids for x best
    selected_parents = []
    for i in range(x):
        selected_parents.append(rankings[i][0].get_id())

    return selected_parents


def mutate(id, sudoku):
    """mutate the chromosome of 'sudoku' and return a new sudoku object with id and mutated state"""
    old_chrom = sudoku.get_chromosome()

    # randomly swap 2 'genes'
    i = random.randint(0, len(old_chrom)-1)
    j = random.randint(0, len(old_chrom)-1)
    old_chrom[i], old_chrom[j] = old_chrom[j], old_chrom[i]

    new_chrom = list(old_chrom)

    return Sudoku(id, chrom=new_chrom)
# End genetic algorithms


# Start utility methods
def success(s, sim, gen):
    """report a success and terminate the program"""
    print(f"SUCCESS: Solution found during simulation {sim+1} in generation {gen}!")
    s.print_grid()
    exit()


def report(sim, gen, best, avg):
    """print a report to the user of current simulation status"""
    print(f'Simulation: {sim}')
    print(f'Generation: {gen}')
    print(f'Best result: Id {best.get_id()} with {best.get_fitness()} contradictions.')
    print(f'Average result: {avg} contradictions.\n')
# End utility methods


def main():
    global all_ids
    global instances
    global current_generation
    global num_parents

    print(info)
    input("Press ENTER to commence simulations...")             # pause program to allow user to read info
    print('\nAlgorithm running....\n')

    initialise(num_instances)

    for i in range(max_simulations):
        for j in range(max_generations):                        # for each generation

            tot = 0                                             # sum fitness values encountered to calculate average
            for s in instances:
                if s.get_fitness() == 0:                        # detect solution in current generation
                    success(s, i, current_generation)           # calls exit()
                tot += s.get_fitness()

            best = selection(num_parents, instances)            # get ids of best performing parents
            eliminated = (set(all_ids) - set(best))             # get all other ids

            new_gen = []

            for id in best:                                     # copy parent solutions to new generation
                new_gen.append(copy.deepcopy(instances[id]))

            for id in eliminated:
                parent_id = random.choice(best)                 # randomly select parent to help genetic diversity
                parent = copy.deepcopy(instances[parent_id])

                child = mutate(id, parent)                      # child sudoku to take the place of eliminated id
                new_gen.append(child)

            new_gen.sort(key=lambda x: x.get_id())              # sort by id to correct instance order

            if current_generation % 50 == 0 or current_generation == 1:
                report(i+1, j+1, instances[best[0]], tot/num_instances)     # periodical feedback for user

            current_generation += 1
            instances = list(new_gen)

        print(f"Simulation {i + 1} FAILED - solution not found.\n")         # end simulation after max generations
        current_generation = 1                                              # reset
        initialise(num_instances)

    # passed maximum number of simulations and failed to find a solution
    print(f'''Well this is awkward... 
    In testing I never failed to find the solution within {max_simulations} simulations, but it is, ofcourse, possible 
    that this point will be reached. My apologies, please run the program again.''')


if __name__ == '__main__':
    main()
